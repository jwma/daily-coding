## 时机成熟
在前面的文章中，`jump-jump` 后端部分的功能大部分都完成了：
- [x] 生成短链接接口
- [x] 短链接跳转功能
- [x] 短链接数据统计功能
- [x] 获取单个短链接信息接口
- [x] 短链接更新接口（更新短链接设置，如目标链接、启用禁用）
- [ ] 后台用户验证
- [ ] 短链接数据报表

明显可以看出，已实现的后端功能，都是为了让 `jump-jump` 能够尽快跑起来（能跳转、能新建短链接、能统计短链接的请求数据、更新短链接），在产品开发中有个术语，`minimum viable product`，简称 `MVP`，即 `最简可行产品`，在开发 `jump-jump` 时，我也是冲着 `最简可行产品` 的目标去的。当然，剩下的功能会在合适的时候加入。

我想也是时候讲讲我会怎么开发前端应用了，一个大前提是，前后端分离。如果理性分析的话，其实 `jump-jump` 这个项目不做前后端分离会更简单，但为了之后要讲前后端分离的实践，所以 `jump-jump` 会是一个前后端分离的项目，这也符合大多数公司的需求。

## 好与坏
前后端分离，能够为开发项目时带来一些好处和解决一些问题：
- 前端可以采用一些业界流行的更为激进的前端方案，有利于前端人员水平提升；
- 理清前后端人员的职责，前后端人员只需要专注自己的部分即可；
- 前后端项目可以分开，独立管理，有利于独立部署。

除了好处，当然也会有一些理由让一些人不愿意前后端分离：
- 后端人员可能会说：以往前端只需要在项目里套模板就好，前后端分离后，还需要定义接口，还需要编写接口文档，增加了对接成本；
- 运维人员可能会说：以前只需要部署一个项目，前后端分离之后还需要为前端项目单独部署；
- 前端人员可能会说：怎么突然又要学习这么多技术。

但如果还是以上面的理由拒绝前后端分离，我觉得已经毫无意义了，毕竟前后端分离经过这么多年的沉淀，很多问题都不是问题，很多理由也不成理由了。

## 需要解决什么问题
`jump-jump` 前后端分离，已经是板上钉钉的事了，那在实践前后端分离时，我们都需要解决什么问题呢？
- 技术选型；
- 前后端通信凭证；
- 前后端联调;
- 部署；

### 技术选型
`jump-jump` 的后端技术已经定了，就是用 `beego`，对前端来说，后端只提供了 `API` 服务；而前端技术，将会使用 `Vue.js` 来搭建，使用新发布 `@vue/cli` 来创建项目。

`beego`，是一个使用 Go 的思维来帮助您构建并开发 Go 应用程序的开源框架，具有 `简单化`、`智能化`、`模块化`、`高性能` 的特性，能够快速上手。

`Vue.js`，是一个 Javascript 的框架，具有 `易用`、`灵活`、`高效` 的特性，下面是 `Vue.js` 官方的介绍视频：

`@vue/cli`，是一个基于 `Vue.js` 进行快速开发的完整系统，在以前版本中，可能只是简单的项目脚手架，但新版中，作者和社区加入了更多功能，让 `Vue.js` 的生态变得更健全。这是 `@vue/cli` 官方中文介绍文档 https://cli.vuejs.org/zh/guide/。

### 前后端通信凭证
既然前后端进行了分离，我们可以把前端应用看作是与 `iOS App` 或者 `Android App` 同等的级别，前端应用与后端之间的通信凭证是 `Token` ，有了 `Token`，我们就能确认请求方的身份。

在 `jump-jump` 中，`JWT` 将会担任这个重要的角色。
`JWT` 全称 `JSON Web Token`，是一个开放的标准，而实现了这个标准的 `Token` 就是 `JWT`。

#### 讲讲 JWT
先祭出官方文档：
https://jwt.io/introduction/

在标准的 `JWT` 中，包含有三个部分，`Header`、`Payload` 和 `Signature`，每个部分经过 Base64 编码后再使用 `.` 进行连接，一个 `JWT` 看起来是这样子的：`xxxxx.yyyyy.zzzzz`。下面对每个部分进行简单的讲解。

##### Header
`Header` 的组成通常有两部分：
1. 令牌类型
2. 加密算法

这是一个 `Header` 的示例：
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

##### Payload
`Payload` 是 `JWT` 的具体内容，里面包含一些标准字段，也可以包含使用者的一些自定义字段如：`uid`、`isAdmin` 等等，后端拿到 `JWT` 并验证解析后，可以读取到这里面的数据，进而处理相应的逻辑，下面是一些常用的标准字段：
- iss: Issuer，令牌发行者
- exp: Expiration time，令牌过期时间
- nbf: Not before，别在这个时间之前使用这个令牌
- iat: Issue at，令牌颁发时间
- jti: JWT ID，令牌 ID

更多标准字段可以查看这里（https://tools.ietf.org/html/rfc7519#section-4.1）， 许多实现了 `JWT` 的第三方库都提供了对标准字段的检查和相关的判断方法，如检查令牌是否过期，所以说，这些标准字段并非强制使用，但还是建议使用。下面给出一个 `Payload` 的示例：
```json
{
  "iss": "jumpjump.com",
  "exp": "1535523249",
  "uid": "xxxxxx",
  "isAdmin": true
}
```

##### Signature
`Signature`，是用于校验一个 `JWT` 是否合法的依据，具体是这样生成的：
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

代码中的 `secret`，就是用于生成签名的密钥，这个密钥必须妥善保管，只要密钥没有泄露，别人想篡改 `JWT` 的 `Palyload`，几乎是不可能的。

更多关于 `JWT` 的内容，在以后使用到时会再提到。

### 前后端联调
在开发过程中，接口的联调是必然的，前端人员按照后端人员提供的接口文档，需要编写接口的请求和处理逻辑，但既然前后端已分离，也就是说后端项目是运行在其他端口上的，更多情况是运行在后端人员本地的某个端口，又或是接口已经部署到测试服务器。
为了解决在开发时前后端联调时的通信问题，我们可以使用一些代理工具来解决，把请求代理到真正的接口地址：
- 前端人员通过 `Nginx` 设置相关代理信息，实现接口代理；
- 使用 `webpack-dev-server`；值得高兴的是，`@vue/cli` 生成的项目中，天生具有这种能力。

通过简单的配置，前端开发人员就可以在本地轻松访问到接口了，剩下的事情就是对接接口实现业务逻辑。

### 部署
前后端分离，前端项目和后端项目一般都是物理分离的，都有自己独立的项目文件，在部署时方式也不大一样。
`jump-jump` 会以最简单的方式进行前后端项目的部署：使用 `Nginx`，分别为同一个域名下的不同 `path` 指定前后端项目。

## 写在最后
本文分享 `jump-jump` 在实践前后端分离架构时所用到的技术、需要解决的问题以及一些技术的介绍，在后面的文章会逐一进行各个部分的分享，希望分享的内容对你有帮助。
