## 前情回顾
在上一篇 [码极系列-07 | 请对用户密码负责](https://mp.weixin.qq.com/s?__biz=Mzg5ODAwODM0Mg==&mid=2247483725&idx=1&sn=cf0cd0822f16469dbe0c578fd454b684&chksm=c0685534f71fdc228867e27a1153de7d515c52e98930daf274028338d05392ab708924e371e9&token=469519358&lang=zh_CN#rd) 分享中，提到了如何的安全存储用户的密码，也实现了登录接口，这次的分享，则会讲讲 `Token-Based` 的身份认证。

### JWT（JSON Web Token）
在 [码极系列-04 | 谈谈前后端分离](https://mp.weixin.qq.com/s?__biz=Mzg5ODAwODM0Mg==&mid=2247483697&idx=1&sn=0b93fb2f83a246c8a008fc74b8f86cf7&chksm=c0685548f71fdc5edf8a45d3d7865dcac3fe086f0b64a050687c9ae75e762228be5e9dbe91ca&token=469519358&lang=zh_CN#rd) 分享中，已经提到过 `JWT`，`jump-jump` 中登录成功后返回的登录凭证 `Token`，就是一个实现了 `JWT` 的实例，如果对 `JWT` 还不够了解的，可以到这篇分享中看看。

## 身份认证机制
我们的项目采用了前后端分离的架构进行开发，后端提供接口，前端调用接口实现逻辑，而中间的通信，一般采用 `HTTP` 协议，`HTTP` 协议是不存储状态的（stateless），既然是无状态，也就是说在每次请求接口时需要告诉后台你是谁。

下面会说说一般都有什么途径告诉后台你是谁。

### Session-Based 身份认证
在传统的应用中，当用户登录成功后，我们会把登录态记录到 `Session`，`Session` 可以保存在文件、内存或是数据库，然后会把 `SessionID` 写入到 `Cookie`，而前端每次请求都会携带这个 `Cookie`，后端需要知道当前请求是谁的时候，可以通过 `SessionID` 找到 `Session`，并把的信息读取出来，这样就能获取到如用户 ID 之类的信息了。
其实能看出通过 `Session` 来做这件事情存在一些缺点：
- `Session` 的管理：
  - 读写 `Session` 时的性能问题；
  - 如果存在大量 `Session` 的生成情况，还需要考虑可扩展性的问题；
  - 分布式应用需要将 `Session` 集中管理；
- 多端多平台支持不友善，如果接口需要提供给不同域的网站、服务或是 APP 时，使用 `Session` 更是不可能的。

上面是不完全列举了一些通过 `Session` 进行身份认证的缺点。

### Token-Based 身份认证
在大部分现代应用中，都使用 `Token-Based` 身份认证，在实践过程中，我们能够很容易看出这种身份认证方式的优点：
- 在没有特殊需求时，后端只需要负责签发 `Token`，无需存储，由使用方负责存储，例如一个 Web 应用则可以缓存在用户浏览器的 `localStorage` 中；
- 多端多平台支持友好，每次请求只需要把 `Token` 放到约定好的位置，例如请求头中；
- `Token` 本身就能存储信息，例如用户 ID 等；

在一些特殊需求的场景下，`Token` 还能包含更多信息，也可以把 `Token` 保存在服务器实现更多负责的逻辑处理。

虽然 `Token-Based` 身份认证有很多优点，能够为我们解决开发现代应用中遇到的问题，但同时也存在一些缺点（以 `JWT` 为例）：
- 生成 `Token` 时需要使用加密算法对元数据进行加密，在想读取 `Token` 的信息以及验证 `Token` 时需要解密，这些过程都存在一点性能消耗；
- `Token` 一般比比较大；
- 需要编写更多关于 `Token` 处理的逻辑；
- 使用不当更容易发生安全问题。

可以看出，`Token-Based` 对使用者的要求会更高。

## 实践
在了解过两种身份认证机制后，我们来看看如何应用 `Token-Based` 身份认证。

![前后端的通信过程](https://mmbiz.qpic.cn/mmbiz_png/oS1Ryib0qL8V2kZB2U3nMorEOaxMsYkcFtKTaotiaZOInGUgica5d2FVrUmNZuzmo1u3HVIMtY4ojy4iaaUpdrlrqw/0?wx_fmt=png)

上图我们可以看出大致的通信过程，下面可以通过文字看到更多通信过程的细节。

#### 前端部分
1. 登录成功后，设置登录态到 `store`，缓存登录态信息，跳转到首页
2. 前端路由跳转时，检查路由是否需要验证登录态，如果需要则从 `store` 获取登录态，如果获取失败则跳转到登录页，再次登录成功后跳转至跳转前的页面
3. 请求接口时，带上登录态请求头
4. 通过拦截器拦截服务端返回的信息，如果有需要登录的标识，则跳转到登录页
5. 前端应用首次加载时，尝试从缓存中获取登录态信息并设置登录态信息到 `store`
6. 前端应用首次加载时，请求一次检查登录态的接口，用于校验当前登录态是否合法，不合法则调整到登录页
7. 前端应用登出时，清除 `store` 和缓存中的登录态信息

#### 后端部分
- 登录接口
  - 登录成功后，签发一个 `Token`
- `Token` 验证拦截器
  - 通过拦截器实现对部分需要验证登录态的接口进行拦截并对请求头的 `Token` 进行验证
  - 如果验证通过，则从 `Token` 的 `Payload` 中读取用户标识（用户名）
- 检查登录态接口
  - 接口获取请求头中的 `Token` 并校验，返回校验结果

根据上面的流程，我们就可以开始编写每部分对应的代码了，实际代码太多，这里就不一一贴出来了，可以到这里查看：https://github.com/jwma/jump-jump

## 写在最后
由于 `jump-jump` 只是一个小型的项目，所以对 `Token` 的各种要求的不高，如果在中大型的产品中要使用，其实还有一些问题要解决：
- `Token` 怎么续签；
- `Token` 怎么注销；
- 解决重放问题。

上面列出比较重要的问题，能看出 `Token` 对使用者的要求其实比较高，需要自己把配套的各种方案都想好。
